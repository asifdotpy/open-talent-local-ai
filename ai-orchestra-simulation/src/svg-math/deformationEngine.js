/**
 * @file Geometry Deformation Engine
 *
 * This engine is the heart of the SVG-to-3D conversion pipeline. It takes the
 * 2D SVG paths generated by the PathGenerator and the vertex maps from the
 * FacialRegionMapper and calculates the new 3D positions for the facial vertices.
 *
 * The core principle is to project the 2D SVG path onto the 3D facial surface,
 * preserving the original depth and anatomical structure of the face while
 * applying the new expression shape.
 */

import * as THREE from 'three';
import { Logger } from '../utils/Logger.js';
import { cubicBezier } from './bezierUtils.js';

export class DeformationEngine {
  constructor(facialRegionMapper) {
    this.mapper = facialRegionMapper;
    this.logger = Logger.getInstance();
  }

  /**
   * Deforms a facial region based on a generated SVG path.
   *
   * @param {string} regionName - The name of the region to deform (e.g., 'mouth').
   * @param {string} svgPath - The SVG path data string (e.g., from generateMouthPath).
   * @param {object} originalPositions - A buffer attribute of the original vertex positions.
   * @returns {Map<number, THREE.Vector3>} A map of vertex indices to their new 3D positions.
   */
  deformRegion(regionName, svgPath, originalPositions) {
    const region = this.mapper.getRegion(regionName);
    if (!region || region.vertices.length === 0) {
      this.logger.log('WARN', `Cannot deform region "${regionName}": No vertices mapped.`);
      return new Map();
    }

    const { vertices, boundingBox } = region;
    const newPositions = new Map();

    // For simplicity, this initial implementation will focus on the mouth
    // and use a horizontal projection. A more advanced implementation would
    // use surface normals for projection.
    if (regionName.includes('mouth')) {
      const pathPoints = this.sampleSvgPath(svgPath, 100);

      for (const vertexData of vertices) {
        const originalVertex = new THREE.Vector3().fromBufferAttribute(originalPositions, vertexData.index);

        // 1. Normalize the vertex's X position within its bounding box (0 to 1)
        const normalizedX = (originalVertex.x - boundingBox.minX) / (boundingBox.maxX - boundingBox.minX);

        // 2. Find the corresponding point on the 2D SVG path
        const pathIndex = Math.round(normalizedX * (pathPoints.length - 1));
        const pathPoint = pathPoints[pathIndex];

        // 3. Create the new 3D position
        // We use the new Y from the path, but preserve the original X and Z.
        // This is a simplification. A better approach would be to use the
        // original surface normal to offset the vertex.
        const newPosition = new THREE.Vector3(
          originalVertex.x,
          pathPoint.y, // This assumes the SVG's Y-coord maps to the model's Y-coord
          originalVertex.z
        );

        newPositions.set(vertexData.index, newPosition);
      }
    }

    this.logger.log('DEFORM', `Deformed ${newPositions.size} vertices in region "${regionName}".`);
    return newPositions;
  }

  /**
   * Samples a cubic Bezier SVG path into an array of points.
   * NOTE: This is a simplified parser for 'M C' paths only.
   *
   * @param {string} svgPath - The SVG path string.
   * @param {number} numPoints - The number of points to sample.
   * @returns {THREE.Vector2[]} An array of 2D points.
   */
  sampleSvgPath(svgPath, numPoints) {
    const parts = svgPath.replace('M', '').replace('C', ',').split(/[ ,]+/);
    const points = parts.map(p => parseFloat(p));

    if (points.length < 8) return [];

    const p0 = { x: points[0], y: points[1] };
    const p1 = { x: points[2], y: points[3] };
    const p2 = { x: points[4], y: points[5] };
    const p3 = { x: points[6], y: points[7] };

    const sampledPoints = [];
    for (let i = 0; i <= numPoints; i++) {
      const t = i / numPoints;
      sampledPoints.push(cubicBezier(p0, p1, p2, p3, t));
    }
    return sampledPoints;
  }
}
