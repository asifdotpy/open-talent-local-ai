rules:
  # ==========================================================================
  # LOOSE STRING VALIDATION (The issue we just fixed)
  # ==========================================================================
  - id: loose-string-enum-validation
    pattern-either:
      - pattern: |
          status: str = Field(..., min_length=$N, max_length=$M)
      - pattern: |
          $VAR: str = Field(..., min_length=$N, max_length=$M)
    message: |
      Use Python Enum instead of loose string validation for status/enum fields.
      
      Bad:  status: str = Field(min_length=1, max_length=100)
      Good: status: ApplicationStatus = Field(...)
      
      See CODE_QUALITY_AUDIT_ENUM_VALIDATION.md for details.
    severity: WARNING
    languages: [python]
    paths:
      include:
        - "*.py"
      exclude:
        - "tests/"
        
  # ==========================================================================
  # HARDCODED SECRETS
  # ==========================================================================
  - id: hardcoded-jwt-secret
    pattern-either:
      - pattern: SECRET_KEY = "$VALUE"
      - pattern: JWT_SECRET = "$VALUE"
      - pattern: API_KEY = "$VALUE"
    message: |
      Secret keys should be loaded from environment variables, not hardcoded.
      
      Bad:  SECRET_KEY = "my-secret-key"
      Good: SECRET_KEY = os.environ.get("JWT_SECRET_KEY")
    severity: ERROR
    languages: [python]
    
  # ==========================================================================
  # GENERIC DICT PAYLOADS
  # ==========================================================================
  - id: dict-payload-validation
    pattern-either:
      - pattern: |
          async def $FUNC(..., payload: dict = Body(...), ...):
            ...
      - pattern: |
          def $FUNC(..., data: dict = Body(...), ...):
            ...
    message: |
      Use Pydantic models instead of dict for payload validation.
      This ensures type safety, validation, and OpenAPI schema generation.
      
      Bad:  async def create_user(payload: dict = Body(...)):
      Good: async def create_user(payload: UserCreate):
    severity: WARNING
    languages: [python]
    paths:
      include:
        - "services/*/main.py"
        
  # ==========================================================================
  # INSECURE PASSWORD HASHING
  # ==========================================================================
  - id: sha256-password-hashing
    pattern-either:
      - pattern: sha256($PASSWORD.encode())
      - pattern: hashlib.sha256($PASSWORD.encode())
      - pattern: md5($PASSWORD.encode())
      - pattern: hashlib.md5($PASSWORD.encode())
    message: |
      SHA256/MD5 are not suitable for password hashing. Use bcrypt or argon2.
      
      Bad:  password_hash = sha256(password.encode()).hexdigest()
      Good: from passlib.context import CryptContext
            pwd_context = CryptContext(schemes=["bcrypt"])
            password_hash = pwd_context.hash(password)
    severity: ERROR
    languages: [python]
    
  # ==========================================================================
  # SQL INJECTION
  # ==========================================================================
  - id: sql-injection-risk
    pattern-either:
      - pattern: |
          $QUERY = f"SELECT ... {$VAR} ..."
          ...
          $DB.execute($QUERY)
      - pattern: |
          $QUERY = "SELECT ... " + $VAR + " ..."
          ...
          $DB.execute($QUERY)
    message: |
      Potential SQL injection. Use parameterized queries.
      
      Bad:  query = f"SELECT * FROM users WHERE email = '{email}'"
      Good: query = "SELECT * FROM users WHERE email = :email"
            result = await db.fetch_one(query, values={"email": email})
    severity: ERROR
    languages: [python]
    
  # ==========================================================================
  # COMMAND INJECTION
  # ==========================================================================
  - id: command-injection-risk
    pattern-either:
      - pattern: os.system($CMD)
      - pattern: subprocess.call($CMD, shell=True)
      - pattern: subprocess.run($CMD, shell=True)
      - pattern: subprocess.Popen($CMD, shell=True)
    message: |
      Command injection risk. Avoid shell=True and use list arguments.
      
      Bad:  os.system(f"convert {user_file} output.png")
      Good: subprocess.run(["convert", user_file, "output.png"], check=True)
    severity: ERROR
    languages: [python]
    
  # ==========================================================================
  # INSECURE RANDOM
  # ==========================================================================
  - id: insecure-random-token
    pattern-either:
      - pattern: random.randint(...)
      - pattern: random.random()
      - pattern: random.choice(...)
    message: |
      Use secrets module for cryptographic randomness, not random module.
      
      Bad:  token = random.randint(100000, 999999)
      Good: import secrets
            token = secrets.randbelow(900000) + 100000
    severity: WARNING
    languages: [python]
    paths:
      include:
        - "services/*/main.py"
      exclude:
        - "tests/"
        
  # ==========================================================================
  # MISSING AUTHORIZATION CHECK
  # ==========================================================================
  - id: missing-authorization-check
    pattern: |
      @app.$METHOD("/api/v1/...")
      async def $FUNC(...):
        ...
    message: |
      Protected endpoint might be missing authorization check.
      Ensure Depends(get_current_user) or equivalent is present.
    severity: INFO
    languages: [python]
    
  # ==========================================================================
  # CORS WILDCARD IN PRODUCTION
  # ==========================================================================
  - id: cors-allow-all-origins
    pattern: |
      CORSMiddleware(
        ...
        allow_origins=["*"],
        ...
      )
    message: |
      CORS wildcard (*) should not be used in production.
      Use environment-specific origin whitelist.
      
      Good: ALLOWED_ORIGINS = os.getenv("ALLOWED_ORIGINS").split(",")
            app.add_middleware(CORSMiddleware, allow_origins=ALLOWED_ORIGINS)
    severity: WARNING
    languages: [python]
    
  # ==========================================================================
  # DEBUG MODE IN PRODUCTION
  # ==========================================================================
  - id: debug-mode-enabled
    pattern-either:
      - pattern: debug=True
      - pattern: DEBUG = True
    message: |
      Debug mode should be disabled in production.
      Use environment variables to control debug mode.
      
      Good: DEBUG = os.getenv("DEBUG", "false").lower() == "true"
    severity: WARNING
    languages: [python]
    
  # ==========================================================================
  # LOGGING SENSITIVE DATA
  # ==========================================================================
  - id: logging-password
    pattern-either:
      - pattern: logger.$METHOD(..., password=..., ...)
      - pattern: logger.$METHOD(..., $PASSWORD, ...)
      - pattern: print(..., password=..., ...)
    message: |
      Passwords/tokens should not be logged.
      Sanitize sensitive data before logging.
    severity: ERROR
    languages: [python]
    
  # ==========================================================================
  # UNSAFE YAML LOADING
  # ==========================================================================
  - id: unsafe-yaml-load
    pattern-either:
      - pattern: yaml.load($DATA)
      - pattern: yaml.load($DATA, Loader=yaml.Loader)
    message: |
      Unsafe YAML loading can execute arbitrary code.
      
      Bad:  yaml.load(data)
      Good: yaml.safe_load(data)
    severity: ERROR
    languages: [python]
    
  # ==========================================================================
  # EVAL/EXEC USAGE
  # ==========================================================================
  - id: dangerous-eval-exec
    pattern-either:
      - pattern: eval($EXPR)
      - pattern: exec($CODE)
    message: |
      eval() and exec() can execute arbitrary code and should be avoided.
      Consider safer alternatives like ast.literal_eval() for data parsing.
    severity: ERROR
    languages: [python]
